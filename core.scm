(define-syntax defrecord
  (syntax-rules ()
    ((_ name name?)
     (begin
       (define name (vector 'name))
       (define (name? datum) (eq? name datum))))
    ((_ name name? (field set-field) ...)
     (begin
       (define (name field ...) (vector 'name field ...))
       (define (name? datum)
         (and (vector? datum) (eq? 'name (vector-ref datum 0))))
       (let ()
         (define (range-assoc start xs)
           (let loop ((xs xs) (idx start))
             (if (null? xs)
               '()
               (cons (cons (car xs) idx) (loop (cdr xs) (+ idx 1))))))
         (define (define-field-getter name rassc)
           (define idx (cdr (assoc name rassc)))
           (eval `(define (,name datum) (vector-ref datum ,idx))))
         (define (define-field-setter name rassc)
           (define idx (cdr (assoc name rassc)))
           (eval `(define (,name datum value)
                    (let ((new (vector-copy datum)))
                      (vector-set! new ,idx value)
                      new))))
         (let ((fns (range-assoc 1 '(field ...))))
           (begin (define-field-getter 'field fns) ...))
         (let ((set-fns (range-assoc 1 '(set-field ...))))
           (begin (define-field-setter 'set-field set-fns) ...)))))
    ((_ name name? field ...)
     (begin
       (define (name field ...) (vector 'name field ...))
       (define (name? datum)
         (and (vector? datum) (eq? 'name (vector-ref datum 0))))
       (let ()
         (define (range-assoc start xs)
           (let loop ((xs xs) (idx start))
             (if (null? xs)
               '()
               (cons (cons (car xs) idx) (loop (cdr xs) (+ idx 1))))))
         (define (define-field-getter name rassc)
           (define idx (cdr (assoc name rassc)))
           (eval `(define (,name datum) (vector-ref datum ,idx))))
         (let ((fns (range-assoc 1 '(field ...))))
           (begin (define-field-getter 'field fns) ...)))))))

;; TODO: hash
(define store-empty '())
(define (store-ref store key . default)
  (let ((binding (assoc key store)))
    (if binding
      (cdr binding)
      (if (null? default)
        (error 'store-ref (format "missing key ~s in ~s" key store))
        (car default)))))
(define (store-set store key value) `((,key . ,value) . ,store))
(define (store-remove store key)
  (if (null? store)
    '()
    (if (eqv? key (caar store))
      (store-remove (cdr store) key)
      (cons (car store) (store-remove (cdr store) key)))))
(define (store-keys store) (map car store))

(define (list-add-unique xs v) (if (member v xs) xs (cons v xs)))
(define (list-append-unique xs ys)
  (if (null? xs)
    ys
    (let ((zs (list-append-unique (cdr xs) ys))
          (x0 (car xs)))
      (if (member x0 ys) zs (cons x0 zs)))))
(define (list-remove-unique xs v)
  (cond
    ((null? xs) '())
    ((equal? v (car xs)) (cdr xs))
    (else (let ((xs1 (list-remove-unique (cdr xs))))
            (if (eq? xs1 (cdr xs))
              xs
              (cons (car xs) xs1))))))
(define (list-subtract xs ys)
  (if (null? xs)
    '()
    (let ((x0 (car xs))
          (xs1 (list-subtract (cdr xs) ys)))
     (if (member x0 ys)
       xs1
       (if (eq? xs1 (cdr xs))
         xs
         (cons x0 xs1))))))
(define (list-overlap? xs ys)
  (and (pair? xs)
       (or (member (car xs) ys))
       (list-overlap? (cdr xs) ys)))
(define (list-intersect xs ys)
  (define rest (list-intersect (cdr xs) ys))
  (if (member (car xs) ys)
    (cons (car xs) rest)
    rest))
