(define-syntax let*/and
  (syntax-rules ()
    ((_ () rest ...) (and rest ...))
    ((_ ((name expr) ne* ...) rest ...)
     (let ((name expr))
       (and name (let*/and (ne* ...) rest ...))))))

(define-syntax defrecord
  (syntax-rules ()
    ((_ name name?)
     (begin
       (define name (vector 'name))
       (define (name? datum) (eq? name datum))))
    ((_ name name? (field set-field) ...)
     (begin
       (define (name field ...) (vector 'name field ...))
       (define (name? datum)
         (and (vector? datum) (eq? 'name (vector-ref datum 0))))
       (let ()
         (define (range-assoc start xs)
           (let loop ((xs xs) (idx start))
             (if (null? xs)
               '()
               (cons (cons (car xs) idx) (loop (cdr xs) (+ idx 1))))))
         (define (define-field-getter name rassc)
           (define idx (cdr (assoc name rassc)))
           (eval `(define (,name datum) (vector-ref datum ,idx))))
         (define (define-field-setter name rassc)
           (define idx (cdr (assoc name rassc)))
           (eval `(define (,name datum value)
                    (let ((new (vector-copy datum)))
                      (vector-set! new ,idx value)
                      new))))
         (let ((fns (range-assoc 1 '(field ...))))
           (begin (define-field-getter 'field fns) ...))
         (let ((set-fns (range-assoc 1 '(set-field ...))))
           (begin (define-field-setter 'set-field set-fns) ...)))))
    ((_ name name? field ...)
     (begin
       (define (name field ...) (vector 'name field ...))
       (define (name? datum)
         (and (vector? datum) (eq? 'name (vector-ref datum 0))))
       (let ()
         (define (range-assoc start xs)
           (let loop ((xs xs) (idx start))
             (if (null? xs)
               '()
               (cons (cons (car xs) idx) (loop (cdr xs) (+ idx 1))))))
         (define (define-field-getter name rassc)
           (define idx (cdr (assoc name rassc)))
           (eval `(define (,name datum) (vector-ref datum ,idx))))
         (let ((fns (range-assoc 1 '(field ...))))
           (begin (define-field-getter 'field fns) ...)))))))

(define store-empty '())
(define (store-ref store key . default)
  (let ((binding (assoc key store)))
    (if binding
      (cdr binding)
      (if (null? default)
        (error 'store-ref (format "missing key ~s in ~s" key store))
        (car default)))))
(define (store-set store key value) `((,key . ,value) . ,store))
(define (store-remove store key)
  (if (null? store)
    '()
    (if (eqv? key (caar store))
      (store-remove (cdr store) key)
      (cons (car store) (store-remove (cdr store) key)))))
(define (store-keys store) (map car store))

(define scope-new
  (let ((index -1))
    (lambda ()
      (set! index (+ 1 index))
      index)))
(define scope-bound #f)
(define scope-nonlocal #t)

(defrecord var var? var-scope var-value)
(define var/scope
  (let ((index -1))
    (lambda (scope)
      (set! index (+ 1 index))
      (var scope index))))
(define var=? eq?)
(define (var<? v1 v2) (< (var-value v1) (var-value v2)))
(define (var-bound? vr) (eq? scope-bound (var-scope vr)))
(define (set-var-value! vr value)
  (vector-set! vr 1 scope-bound)
  (vector-set! vr 2 value))

(define (vattrs-get vs vr) (store-ref vs vr vr))
(define (vattrs-set vs vr value) (store-set vs vr value))
(define (walk-vs vs tm)
  (if (var? tm)
    (if (var-bound? tm)
      (walk-vs vs (var-value tm))
      (let ((va (vattrs-get vs tm)))
        (if (var=? tm va)
          tm
          (walk-vs vs va))))
    tm))

(defrecord state state? (state-scope set-state-scope) (state-vs set-state-vs))
(define (walk st tm) (walk-vs (state-vs st) tm))
(define (var/state st) (var/scope (state-scope st)))
(define (state-empty) (state (scope-new) store-empty))
(define (state-var-get st vr) (vattrs-get (state-vs st) vr))
(define (state-var-set st vr value)
  (if (eqv? (state-scope st) (var-scope vr))
    (begin (set-var-value! vr value) st)
    (set-state-vs st (vattrs-set (state-vs st) vr value))))

(define (not-occurs? st vr tm)
  (if (pair? tm)
    (let*/and ((st (not-occurs? st vr (walk st (car tm)))))
      (not-occurs? st vr (walk st (cdr tm))))
    (and (not (var=? vr tm)) st)))
(define (state-var-== st vr value)
  (let*/and ((st (not-occurs? st vr value)))
    (state-var-set st vr value)))
(define (state-var-==-var st v1 va1 v2 va2)
  (if (var<? v1 v2)
    (state-var-set st v2 v1)
    (state-var-set st v1 v2)))

(define (unify st t1 t2)
  (let ((t1 (walk st t1)) (t2 (walk st t2)))
    (cond
      ((eqv? t1 t2) st)
      ((var? t1)
       (if (var? t2)
         (state-var-==-var st t1 t2)
         (state-var-== st t1 t2)))
      ((var? t2) (state-var-== st t2 t1))
      ((and (pair? t1) (pair? t2))
       (let*/and ((st (unify st (car t1) (car t2))))
         (unify st (cdr t1) (cdr t2))))
      (else #f))))

(defrecord fresh-vars fresh? fresh-prepare)
(defrecord scoped scoped? scoped-scope scoped-c)
(defrecord conj conj? conj-c1 conj-c2)
(defrecord disj disj? disj-c1 disj-c2)
(defrecord zzz zzz? zzz-metadata zzz-wake)
(defrecord pause pause? pause-state pause-goal)
(defrecord == ==? ==-t1 ==-t2)

(define-syntax define-relation
  (syntax-rules ()
    ((_ (name param ...) body ...)
     (define (name param ...)
       (zzz `(name ,param ...) (lambda () body ...))))))

(define (bind ss goal)
  (cond
    ((not ss) #f)
    ((state? ss) (start ss goal))
    ((pair? ss) (mplus (start (car ss) goal) (conj (cdr ss) goal)))
    (else (conj ss goal))))
(define (mplus s1 s2)
  (cond
    ((not s1) s2)
    ((state? s1) (cons s1 s2))
    ((pair? s1) (cons (car s1) (disj s2 (cdr s1))))
    (else (disj s2 s1))))

(define (prepare scope goal)
  (cond
    ((fresh? goal) ((fresh-prepare goal) scope))
    ((conj? goal) (conj (prepare scope (conj-c1 goal))
                        (prepare scope (conj-c2 goal))))
    ((disj? goal)
     (let ((scope (scope-new)))
       (scoped scope (disj (prepare scope (disj-c1 goal))
                           (prepare scope (disj-c2 goal))))))
    (else goal)))

(define (start st goal)
  (cond
    ((scoped? goal)
     (start (set-state-scope st (scoped-scope goal)) (scoped-c goal)))
    ((conj? goal) (bind (start st (conj-c1 goal)) (conj-c2 goal)))
    ((disj? goal) (disj (pause st (disj-c1 goal)) (pause st (disj-c2 goal))))
    ((zzz? goal) (start st (prepare (state-scope st) ((zzz-wake goal)))))
    ((==? goal) (unify st (==-t1 goal) (==-t2 goal)))))

(define (continue ss)
  (cond
    ((conj? ss) (bind (continue (conj-c1 ss)) (conj-c2 ss)))
    ((disj? ss) (mplus (continue (disj-c1 ss)) (disj-c2 ss)))
    ((pause? ss) (start (pause-state ss) (pause-goal ss)))))

(define (stream-take n ss)
  (cond
    ((and n (= 0 n)) '())
    ((not ss) '())
    ((state? ss) (list ss))
    ((pair? ss) (cons (car ss) (stream-take (and n (- n 1))
                                            (continue (cdr ss)))))
    (else (stream-take n (continue ss)))))

;; TODO: steer, a continue that prompts for choices.

(define succeed (== #t #t))
(define fail (== #f #t))

(define-syntax conj*
  (syntax-rules ()
    ((_) succeed)
    ((_ g) g)
    ((_ gs ... g-final) (conj (conj* gs ...) g-final))))
(define-syntax disj*
  (syntax-rules ()
    ((_) fail)
    ((_ g) g)
    ((_ g0 gs ...) (disj g0 (disj* gs ...)))))

(define-syntax fresh
  (syntax-rules ()
    ((_ (vr ...) g0 gs ...)
     (fresh-vars (lambda (scope)
                   (let ((vr (var/scope scope)) ...)
                     (prepare scope (conj* g0 gs ...))))))))
(define-syntax conde
  (syntax-rules ()
    ((_ (g0 gs ...)) (conj* g0 gs ...))
    ((_ c0 cs ...) (disj* (conde c0) (conde cs ...)))))

(define (run-goal n st goal)
  (stream-take n (start (set-state-scope st scope-nonlocal) (prepare (state-scope st) goal))))

;; TODO: reify, run
